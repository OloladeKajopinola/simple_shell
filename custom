#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BUFFER_SIZE 1024

char *custom_getline(void) {
    static char buffer[BUFFER_SIZE]; // Static buffer to store input
    static size_t index = 0; // Index to keep track of position in buffer
    static ssize_t bytes_read = 0; // Number of bytes read into buffer
    char *line = NULL;
    size_t line_length = 0;

    while (1) {
        // If buffer is empty, read more characters from input
        if (index >= bytes_read) {
            bytes_read = read(STDIN_FILENO, buffer, BUFFER_SIZE);
            if (bytes_read <= 0) {
                // No more input or error, return NULL to indicate end
                if (line_length == 0) {
                    return NULL;
                }
                break;
            }
            index = 0;
        }

        // Find the next newline character or end of buffer
        while (index < bytes_read && buffer[index] != '\n') {
            index++;
            line_length++;
        }

        // Allocate memory for the line and copy characters
        line = realloc(line, line_length + 1);
        if (!line) {
            perror("realloc");
            exit(1);
        }

        // Copy characters from buffer to line
        size_t copy_start = index - line_length;
        strncat(line, buffer + copy_start, line_length);

        // If newline found, move index past newline and break
        if (index < bytes_read && buffer[index] == '\n') {
            index++;
            break;
        }
    }

    // Null-terminate the line
    if (line) {
        line[line_length] = '\0';
    }

    return line;
}

int main(void) {
    while (1) {
        printf("(Myshell)$ ");
        fflush(stdout);

        char *line = custom_getline();
        if (!line) {
            printf("Exiting Myshell.......\n");
            break;
        }

        printf("You entered: %s\n", line);
        free(line);
    }

    return 0;
}

